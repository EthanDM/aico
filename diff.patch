diff --git a/config.example.json b/config.example.json
index f673a1f..8c86b6b 100644
--- a/config.example.json
+++ b/config.example.json
@@ -12,7 +12,8 @@
     "maxBodyLength": 200,
     "wrapBody": 72,
     "includeBody": "auto",
-    "includeFooter": false
+    "includeFooter": false,
+    "scopeRules": []
   },
   "debug": {
     "enabled": false,
diff --git a/src/constants/openai.constants.ts b/src/constants/openai.constants.ts
index 20d0d0b..1fe8043 100644
--- a/src/constants/openai.constants.ts
+++ b/src/constants/openai.constants.ts
@@ -19,6 +19,7 @@ Hard prohibitions:
 - Do not mention logging or refactors unless behavior changes.
 - Use feat only for user-facing product features.
 - For internal code quality, architecture, tooling, prompt/validation/diff processing, use refactor (or chore for pure maintenance).
+- Prefer describing the user-visible behavior change over vague terms like "handling".
 
 Examples:
 refactor(services): use structured diff signals for commit generation
diff --git a/src/services/Config.service.ts b/src/services/Config.service.ts
index c896811..ccf3609 100644
--- a/src/services/Config.service.ts
+++ b/src/services/Config.service.ts
@@ -29,6 +29,7 @@ class ConfigService {
       wrapBody: 72,
       includeBody: 'auto',
       includeFooter: false,
+      scopeRules: [],
     },
     debug: {
       enabled: false,
diff --git a/src/services/OpenAI.service.ts b/src/services/OpenAI.service.ts
index c850cc3..4a6ea61 100644
--- a/src/services/OpenAI.service.ts
+++ b/src/services/OpenAI.service.ts
@@ -38,6 +38,28 @@ const VAGUE_SUBJECT_PATTERNS = [
   /^(feat|fix|docs|style|refactor|test|chore|build|ci|perf|revert)(\([a-z0-9-]+\))?: various changes$/i,
 ]
 
+const VAGUE_DESCRIPTION_WORDS = [
+  'handling',
+  'logic',
+  'process',
+  'stuff',
+  'various',
+]
+
+const TRAILING_STOP_WORDS = [
+  'and',
+  'or',
+  'with',
+  'for',
+  'to',
+  'in',
+  'on',
+  'at',
+  'from',
+  'into',
+  'by',
+]
+
 interface OpenAIOptions {
   context?: boolean | string
   noAutoStage?: boolean
@@ -563,9 +585,10 @@ export class OpenAIService {
 
   private inferScopeFromPaths(paths: string[]): string | undefined {
     const counts = new Map<string, number>()
+    const scopeRules = this.getScopeRules()
 
     for (const path of paths) {
-      for (const entry of PATH_SCOPE_MAP) {
+      for (const entry of scopeRules) {
         if (entry.match.test(path)) {
           counts.set(entry.scope, (counts.get(entry.scope) || 0) + 1)
         }
@@ -576,6 +599,31 @@ export class OpenAIService {
     return best?.[0]
   }
 
+  private getScopeRules(): { scope: string; match: RegExp }[] {
+    const fallbackRules = [
+      { scope: 'integrations', match: /^src\/screens\/.*\/Integrations\// },
+      { scope: 'translations', match: /^src\/translations\// },
+      { scope: 'services', match: /^src\/services\// },
+    ]
+
+    const rawRules = this.commitConfig.scopeRules || []
+    if (rawRules.length === 0) {
+      return fallbackRules
+    }
+
+    const parsed = rawRules
+      .map((rule) => {
+        try {
+          return { scope: rule.scope, match: new RegExp(rule.match) }
+        } catch {
+          return undefined
+        }
+      })
+      .filter(Boolean) as { scope: string; match: RegExp }[]
+
+    return parsed
+  }
+
   private normalizeSubject(candidate: string): string {
     return candidate.split('\n')[0]?.replace(/\s+/g, ' ').trim() || ''
   }
@@ -632,6 +680,52 @@ export class OpenAIService {
     return text.replace(bannedSubjectPattern, '')
   }
 
+  private isVagueDescription(description: string): boolean {
+    const tokens = description
+      .split(/\s+/)
+      .map((token) => token.toLowerCase())
+      .filter(Boolean)
+    if (tokens.length === 0) return true
+    if (tokens.every((token) => VAGUE_DESCRIPTION_WORDS.includes(token))) {
+      return true
+    }
+    if (tokens.length <= 3) {
+      return tokens.some((token) => VAGUE_DESCRIPTION_WORDS.includes(token))
+    }
+    return false
+  }
+
+  private buildBehaviorTemplateSubject(diff: ProcessedDiff): string | undefined {
+    const paths = diff.signals?.topFiles?.length
+      ? diff.signals.topFiles
+      : diff.signals?.nameStatus?.map((entry) => entry.path) || []
+    const snippets = diff.signals?.patchSnippets?.join('\n') || ''
+
+    const translationsOnly =
+      paths.length > 0 &&
+      paths.every((path) => /^src\/translations\//.test(path))
+    if (translationsOnly) {
+      return 'feat(translations): add integration browse message'
+    }
+
+    const browseModeHints =
+      /Browse available integrations|Select leads first/i.test(snippets) ||
+      /connections\.length\s*===\s*0|rawConnections\.length\s*===\s*0/.test(
+        snippets
+      )
+    if (browseModeHints) {
+      return 'feat(integrations): support browse mode when no leads are selected'
+    }
+
+    const loggingSwap =
+      /console\./.test(snippets) && /AppLogger|LoggerService/.test(snippets)
+    if (loggingSwap && paths.length > 0 && paths.length <= 3) {
+      return 'chore(logging): standardize logging'
+    }
+
+    return undefined
+  }
+
   private repairSubject(
     diff: ProcessedDiff,
     candidate: string
@@ -658,8 +752,13 @@ export class OpenAIService {
       !description ||
       VAGUE_SUBJECT_PATTERNS.some((pattern) =>
         pattern.test(`${type}${scope}: ${description}`)
-      )
+      ) ||
+      this.isVagueDescription(description)
     ) {
+      const template = this.buildBehaviorTemplateSubject(diff)
+      if (template) {
+        return template
+      }
       description = 'align commit flow'
     }
 
@@ -696,12 +795,29 @@ export class OpenAIService {
 
     const rawSlice = description.slice(0, allowed)
     const lastSpaceIndex = rawSlice.lastIndexOf(' ')
-    const candidate =
-      lastSpaceIndex > 0 ? rawSlice.slice(0, lastSpaceIndex).trim() : rawSlice.trim()
+    let candidate =
+      lastSpaceIndex > 0
+        ? rawSlice.slice(0, lastSpaceIndex).trim()
+        : rawSlice.trim()
+    candidate = candidate.replace(/[-:,.]+$/, '').trim()
+    candidate = this.trimTrailingStopWord(candidate)
     const cleaned = candidate.replace(/[-:,.]+$/, '').trim()
     return `${prefix}${cleaned}`.trim()
   }
 
+  private trimTrailingStopWord(text: string): string {
+    const words = text.split(/\s+/).filter(Boolean)
+    if (words.length === 0) return text
+    while (words.length > 1) {
+      const lastWord = words[words.length - 1].toLowerCase()
+      if (!TRAILING_STOP_WORDS.includes(lastWord)) {
+        break
+      }
+      words.pop()
+    }
+    return words.join(' ')
+  }
+
   private buildSafeFallbackSubject(
     diff: ProcessedDiff,
     candidate?: string
@@ -960,28 +1076,36 @@ export class OpenAIService {
       const rawContent = response.choices[0]?.message?.content || ''
       const content = rawContent.trim()
       const finishReason = response.choices[0]?.finish_reason
-      if (!content) {
-        if (isRetry) {
-          break
-        }
-        if (lastMessage) {
-          break
-        }
-        throw new Error('No commit message generated')
+    if (!content) {
+      if (isRetry) {
+        break
       }
-
-      if (isRetry && finishReason !== 'stop') {
+      if (lastMessage) {
         break
       }
+      throw new Error('No commit message generated')
+    }
 
-      const parsedMessage = this.parseCommitMessage(rawContent)
-      lastMessage = parsedMessage
+    if (isRetry && finishReason !== 'stop') {
+      break
+    }
 
-      const internalChange = this.isInternalToolingChange(diff)
-      const truncatedSubjectOnly: CommitMessage = {
-        title: this.truncateSubjectToMax(
-          parsedMessage.title,
-          this.commitConfig.maxTitleLength
+    const parsedMessage = this.parseCommitMessage(rawContent)
+    lastMessage = parsedMessage
+
+    const templateSubject = this.buildBehaviorTemplateSubject(diff)
+    if (
+      templateSubject &&
+      this.isValidSubject(templateSubject, this.commitConfig.maxTitleLength)
+    ) {
+      return { title: templateSubject, body: undefined }
+    }
+
+    const internalChange = this.isInternalToolingChange(diff)
+    const truncatedSubjectOnly: CommitMessage = {
+      title: this.truncateSubjectToMax(
+        parsedMessage.title,
+        this.commitConfig.maxTitleLength
         ),
         body: undefined,
       }
@@ -1023,8 +1147,7 @@ export class OpenAIService {
         return subjectOnly
       }
 
-      const { structural } = this.splitValidationErrors(validation.errors)
-      if (structural.length === 0) {
+      if (this.containsFilePathOrExtension(parsedMessage.title)) {
         const repaired = this.repairSubject(diff, parsedMessage.title)
         if (repaired) {
           LoggerService.debug(
@@ -1032,15 +1155,26 @@ export class OpenAIService {
           )
           return { title: repaired, body: undefined }
         }
-        return {
-          title: this.buildSafeFallbackSubject(diff, parsedMessage.title),
-          body: undefined,
-        }
       }
 
-      const nonBodyErrors = validation.errors.filter(
-        (error) => !error.startsWith('Body ')
-      )
+      const { structural } = this.splitValidationErrors(validation.errors)
+    if (structural.length === 0) {
+      const repaired = this.repairSubject(diff, parsedMessage.title)
+      if (repaired) {
+        LoggerService.debug(
+          `Repaired subject locally: "${parsedMessage.title}" -> "${repaired}"`
+        )
+        return { title: repaired, body: undefined }
+      }
+      return {
+        title: this.buildSafeFallbackSubject(diff, parsedMessage.title),
+        body: undefined,
+      }
+    }
+
+    const nonBodyErrors = validation.errors.filter(
+      (error) => !error.startsWith('Body ')
+    )
       const onlyTooLong =
         nonBodyErrors.length === 1 &&
         nonBodyErrors[0]?.includes('exceeds')
diff --git a/src/types/index.ts b/src/types/index.ts
index 8a6052c..dba61da 100644
--- a/src/types/index.ts
+++ b/src/types/index.ts
@@ -19,6 +19,14 @@ export const ConfigSchema = z.object({
     wrapBody: z.number().default(72),
     includeBody: z.enum(['auto', 'never', 'always']).default('auto'),
     includeFooter: z.boolean().default(false),
+    scopeRules: z
+      .array(
+        z.object({
+          scope: z.string(),
+          match: z.string(),
+        })
+      )
+      .default([]),
   }),
   debug: z.object({
     enabled: z.boolean().default(false),
